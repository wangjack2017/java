

java
1.java中只能传值（其中包括地址值），不传对象。
2.  引用类型的变量在内存中有两块空间，一块是引用本身，另一块是引用指向的对象
3.成员变量和局部变量，成员变量定义在方法外，局部变量放在方法内。
4.关键字static用于声明类成员方法（当修饰一个类方法时候你就可以直接通过类来调用而不需要新建对象。
），final用于声明最终方法
5.java中每一个类形成一个文件，多个文件形成一个包，一个包或一个类相当于现实生活中的一个问题。
6.java中public，private和c中的类似表示公有和私有，这样在类中就有了公有方法和私有方法
7.setter和getter两种方法
8.定义方法是本类的对象用this替代，而调用时要改为具体的本类对象，父类对象用super替代，调用时用父类的对象替代（重点）
9.构造方法就是给定的类一些初始值和默认值，就相当于c语言中的构造函数
10.如果类中有构造方法，在主函数中生成一个类的对象时，一定要用new对对象进行赋值，完成对象的初始化
11.构造方法和普通成员的方法有不同
（1）构造方法的名字和类的名字一致
（2）成员方法是对成员变量进行操作，构造方法是对对象进行初始化操作
（3）成员的方法通过对象或者类可以调用，构造方法必须通过new进行调用（new加类名）
（4）构造方法不可以有返回值的，因为只是对类的初始化，但是成员方法可以有返回值
12.如果程序类中没有构造方法，java会默认产生一个构造方法，只有构造函数可以调用构造函数
13.方法的重载：同一个函数会有不同的参数，有不同的功能，至于在主函数会调用哪一个取决于参数的类型和个数（重点）
14.构造函数可以根据参数的个数和类型进行重载
15.为什么要使用this引用:用于在本类中对成员的访问，被起名叫做java
this的三种引用
（1）：访问成员
（2）：返回对象，操作对象
（3）：调用本类重载的构造函数（保留）
16.java中类的成员包括实例成员和类成员，类成员和静态成员用static来修饰，实例成员不能用static修饰
17.类成员它是不受对象的影响的，属于类，也就是可以独立于对象而被调用，就是当对象没有被创建的时候也可以被调用，不可以被覆盖的
18.**实例成员和类成员的区别**
（1）使用类名可以调用类成员和类方法，但是实例成员和方法只能通过类创建的对象调用
（2）两者在声明上差别在于static
(3)两者在引用上差别在于一个使用对象引用，一个使用类来引用
（4）两者在储存结构上差距在于实例成员，在创建对象的时候，会为每个对象的实例成员分配一个储存空间，而类成员是通过类来调用的，所以程序只
会为一个类成员创建一个储存单元（所以类成员的数据会随着每一次的调用被改变）重点**
19.**实例方法和类成员方法的区别**

（1）声明的时候类方法有static,实例方法不需要
（2）两者调用的差别
（3）实例成员方法既可以调用实例成员，也可调用类成员，还可以使用this代替当前对象，但是类方法只能访问类成员，不可使用this.
20.对成员的访问
（1）继承访问
（2）引用访问
（3）方法内间接访问
21.继承是对代码的重用，节省代码的编写，加强了父类与子类之间的一个整体封装，但是削弱了个体之间的各自封装。
22.java只有单重继承，没有多重继承。以个子类只能有一个父类，一个父类可以有多个子类，一对多
23.***继承的情形***：
（1）子类继承父类的非私有成员的变量，包括实例成员变量和类成员变量
（2）子类继承除构造函数以外成员的方法，包括实例成员方法和类成员方法
24.***不可继承的情形***：
（1）子类不能继承父类的构造方法
（2）子类不能继承父类私有成员，其他访问权限的成员是可以被访问的
（3）子类不能继承父类中final修饰的方法
（4）子类不能继承父类中被隐藏的成员变量和被覆盖的成员方法
25.***其他***：
（1）子类不能删除父类的成员
（2）子类可以增加自己的成员和方法
（3）子类可以重定义父类成员，包括隐藏父类的成员变量，静态方法和覆盖父类的实例成员
（4）在子类中可以重载父类中已有的方法，包括构造函数，实例方法
（5）在子类的构造函数中，可通过super（）方法将父类的变量初始化
（6）当父类为抽象类时，子类可覆盖父类中的抽象方法并在子类中实现该方法
（7）在子类中如果没有将父类中的成员在构造函数中初始化，那么在类方法中调用super来访问父类成员，则以父类的值为准（即使在子类中已经给这个
成员变量重新赋值了）
26.java中的类都是Object的子类
27.***对象的赋值相容性与上转型***
上转型的意思就是把子类的对象赋值给父类的一个变量，所以对子类的对象进行了瘦身，不再拥有子类的方法
下转型：必须在上转型的基础上才可以进行操作
28.***子类重定义父类成员的情况***
（1）对于成员变量和静态方法，子类的隐藏父类的。上转型引用的是父类的。
（2）对于实例成员方法，子类覆盖覆盖父类的。上转型对象引用的是子类的。这种方式称为动态绑定
（3）子类继承并重载父类成员方法
29.覆盖：静态方法和最终方法（带有关键字final的方法）不能被覆盖
子类的实例方法覆盖父类的实例方法，子类的静态方法隐藏父类的静态方法
30.对于成员如果子类和父类都有，便属于隐藏或覆盖
31.super与this的区别
this可以单独使用，super不可以，super不是一个变量
32.super的使用
（1）super只在子类中使用
（2）super不能引用父类的私有成员
33.在编译阶段，编译器会制造两种表：一种为叫做方法表，一种叫做常量表
34.继承类优先级由高到低依次为this.show(obj),super.show(obj),this.show((super)obj),super.show((super)obj)
35.抽象类：由abstract修饰的
抽象类：（1）抽象类中可以不包含抽象方法，但是包含抽象方法的类必须被申明为抽象类
	（2）抽象类不能被实例化，即使抽象类中没有包含抽象方法，也不能创建抽象类的实列
36.抽象方法
（1）抽象方法必须被子类覆盖
（2）不能将构造方法和类成员方法声明为抽象类
（3）abstract抽象方法不能和static同用
（4）父类的非抽象方法可以被子类的抽象方法覆盖
37.接口的方法默认是公有的抽象的，但类来实现接口方法时一定要定义为public，接口的成员方法都是抽象的实例成员方法，接口中
的成员方法必须被实现接口的类的方法覆盖，否则就要定义为抽象类。
38.接口中的成员变量必须是常量，接口不能被实例化，接口是引用数据类型，接口变量能够获得实现接口的类的对象，如果用public来修饰
接口，则接口必须与文件名相同
39.接口和抽象类
相同点：（1）两者都含有抽象方法
	（2）都不可以被实例化
	（3）都是引用数据类型
不同点：（1）抽象类约定了子类之间共同使用的方法，接口约定的是互不相关的类之间共同使用的方法
	（2）抽象类实现的是单继承，接口实现的是多继承
40.多态
三种情形：（1）重载（重载 ）
	（2）父类和子类方法的覆盖（覆盖）
	（3）上转型的对象（动态的绑定）
41.*****自动装箱和自动拆箱******
自动装箱：
基本数据类型自动的封装到与他类型相同类型的包装中
自动拆箱：（缓存问题）
包装数据类型自动的转化为数据类型(比如数据在-127到128都是会被自动转化为数据类型）
42.常用的类：时间类。字符串。数字。文件类。
43.语言的发展：机器语言--》汇编语言（汇编语言没有结构化设计原则，大量使用goto语言，不能编写大型软件）--》高级语言（我们现在学的编程语言）
44.人力资源和软件的开发是相互的，人力资源多的时候可以开发大型软件，开发大型软件需要大量的人力资源
45.当下的一些编程语言：c语言（当下使用第二大语言），c++语言（当下使用第三大语言），java当下使用第一大语言，php（网页开发语言）
，object-c语言，javascript语言等
46.java的三个版本：
Javase（标准版）：个人应用：桌面
javaee（企业版）：服务器的应用
javame（微型版）：电子产品的应用上
47.安卓开发的javame开发完全不同
48.Java是在c++的基础上剪掉了很多的头文件，指针，结合，联合，运算符重载等等
49.Java程序不会造成计算机程序的崩溃
50.高级语言一般分为编译型和解释型，Java是两者的结合
51.Java语言执行的过程：Java源文件--》java.class文件--》交给虚拟机（检验字节码，解释字节码）--》交给系统
52.c++语言：源文件--》编译--》交给系统
53.JVM；java虚拟机
54.jre：包含虚拟机，是用来编译和运行程序，jdk：包含jre，用来开发程序
55.三种注释方式：//单行注释     /*。。。。*/多行注释      /**。。。。。*/文档注释 
56.驼峰原则:两个单词的时候第二个单词大写
57.Java中变量包括：局部变量（方法或语块的内部）   成员变量（从属于对象）    静态变量（从属于类）
 58.final修饰的为最终常量是无法修改的
59.取余数运算的结果正负和左边的操作数保持一致
60.位运算：》》右移符号表示乘二，《《左移表示除二
61.类型转化：
自动类型转化：低字节向高字节的转化
强制类型转化：高字节向低字节的转化
62.数据类型的溢出表示超过数据类型的范围了
63.递归：自己调用自己
64.Java中System.out.printf();和c语言中的printf();用法是一样的
65.面向对象和面向过程：
面向过程：适用于简单的不需要协作的，更倾向于的是方法
面向对象：考虑的是某一东西包含的东西，该如何开始操作，准确的说面向对象包括面向过程
66.数据多的时候通过对象来管理二不是用普通的数据类型了，企业项目制和对象的意思差不多（麻雀小，但是五_俱全）
67.内存分析：
内存可分为栈，堆，方法区（也在堆里面）
栈：1.jvm为每一个线程都创建一个栈
2.栈属于线程私有，不能实现线程间的共享
3.每调用一个方法都会开辟一个栈峥
4.先进后出，后进先出
堆:1.用于储存创建好的对象和数组（数组本身也是对象）
2.jvm只有一个堆，被所有的线程共享
方法区：
1.jvm只有一个方法区。被所有的线程共享
2.用于储存类相关的信息（类的相关信息包括：1.代码  2.静态变量  3.静态方法  4.字符串常量）
68.java垃圾回收机制：就是发现无用的对象进行回收
方法：1.引用计数法  2.引用可达法
69.this：本质是创建好的对象的地址，因为在调用构造方法之前对象已经被创建，所以构造方法可以使用this
this不可以用在静态方法中因为静态方法属于类，不属于对象
70.static：用于声明方法和成员，属于类的不属于对象
静态方法里面使用的是静态变量
静态方法里面不可以使用非静态变量
静态语句初始化块
static{

}//用static修饰在类初始化的时候调用
71.参数传值，java中方法所有的参数传值都是值传递
72.包机制：package//通常写在第一句//包名一般就是域名倒着写
用不同包中的类：
两种方法：直接告诉包的地址 地址.类   import +地址
73.继承，object是所有类的根
equals方法一般用来判断对象的内容是否相等
super：构造方法的第一句总是super（）；也就是调用父类的构造器，所以首先先调用的是object的构造方法，然后往回调
74.封装：高内聚，低耦合，内部复杂，外部简单（将类属性包装不让其他类 来访问）
private:本类中可以使用，子类也不可以使用
default：位于用包中都可以使用
protected：同一个包中的类和其他包中的子类可以使用
public :所有都可以使用
75.工作中常用的封装类
一般使用private来修饰类成员，对于成员的访问提供相应的方法
方法一般都用public
76.多态：同一个方法的调用，可以实现不同的效果
三个必要条件：继承，方法的重写，引用父类对象指向子类对象
77.final：
修饰变量表示最终常量ke'yi
修饰方法则不能被子类重写，可以被重载
修饰类表示类不可以被继承
78.为什么java源文件中只能有一个public类：每一个编译单元都有单一的公共接口，有public来实现
79.抽象类：含有抽象方法的类（并不需要所有的方法都是抽象的）抽象方法在子类中必须被重写，一个抽象类可以继承另一个抽象类
80.接口：比抽象类更加抽象，最为抽象
接口里面只有常量和抽象方法
接口的意义：设计与实现的分离，利于分工
接口相当于规章制度，应该是公开的
接口和接口之间也是可以相互继承的
81.回调的实现：模板方式方法，是多态的一个应用
82.实现更好的封装，只能让外部类直接访问，不允许同一个包中的其他类直接访问访问
83.内部类可以访问外部类的成员和方法，但是外部类不可以访问内部类的成员
为什么要使用内部类？
内部类对象可以访问创建它的对象的实现，包括私有数据；
　　　　⒉ 内部类不为同一包的其他类所见，具有很好的封装性；
　　　　⒊ 使用内部类可以很方便的编写事件驱动程序；
　　　　⒋ 匿名内部类可以方便的定义运行时回调；
　　　　5.内部类可以方便的定义
成员内部类：非静态内部类和静态内部类
*************匿名内部类：可以更好的实现定义运行的回调，也可以简化运行开销
使用匿名内部类的注意点：
　									a・匿名内部类不能有构造方法。
　　　　　　b・匿名内部类不能定义任何静态成员、方法和类。
　　　　　　c・匿名内部类不能是public,protected,private,static。
　　　　　　d・只能创建匿名内部类的一个实例。
　　　　　***　e・一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。****
　　　　　　f・因匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。
//用匿名肋部类来实现一个接口
public Iterator<String> print(){
		return new Iterator()
				{
				private int cousor=-1;
				//判断是否有下一个
				public boolean hasNext() {
					return cousor<size-1;
				}
				//获取下一个元素
				public String next() {
					cousor++;
					return map[cousor];
				}
		};

局部内部类
非静态内部类：必须属于外部类的某一个对象，不能有静态成员和静态方法，
静态内部类：1.可以把看成外部类的一个静态成员，属于类
2.静态类部类调用外部类的非静态成员
3.静态内部类存在但是外部类对象不一定存在，所以不能调用外部类的非静态成员
84.String是不可变序列，StringBuilder和StringBuffer是可变序列，可以修改
85.包装类：把数据包装成类，有8种数据类型，列如整型integer
为什么要有包装类：java不是纯面向对象，因为数据类型不是对象
86.Date:日期类 DateFormat:字符串格式化类（为抽象类）子类为：SimpleDateFormat()
日历l类：calender（为抽象类）子类为：GregorianCalendar（）
87.日历代码：import java.text.SimpleDateFormat;
import java.text.DateFormat;
import java.text.ParseException;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Scanner;
/**
 * 
 * 可视化日历程序
 * @author 王思伟
 *
 */
public class calendar120 {
	//判断是否为闰年
	public static int judgeyear(int year) {
		if(year%4==0&&year%100==0||year%400==0) {
			return 1;
		}else
		{
			return 0;
		}
	}
	public static String change(String s,int a) {
		return s+"-"+a;
	}

	public static void main(String[] args) {
		Scanner sca=new Scanner(System.in);
		System.out.println("请输入年，格式为yy");
		String wang=sca.nextLine();
		DateFormat format=new SimpleDateFormat("yyyy-MM");
		try {
			
			for(int k=1;k<=12;k++) {
				int t=0;
				 String wang1=change(wang,k);
				Date date=format.parse(wang1);
				Calendar calendar=new GregorianCalendar();
				calendar.setTime(date);
				calendar.set(Calendar.DATE, 1);
				//获得1号属于星期几
				int ofweek=calendar.get(Calendar.DAY_OF_WEEK);
				//获得一个月的最大天数
				int maxdate=calendar.getActualMaximum(Calendar.DATE);
				System.out.println(k+"月");
				System.out.println("日\t一\t二\t三\t四\t五\t六");
				
				
				for(int i=0;i<ofweek-1;i++) {
					System.out.print("\t");
					t++;
											}
				for(int i=1;i<=maxdate;i++) {
					System.out.print(i+"\t");
					t++;
					if(t%7==0) {
						System.out.println("\n");
								}
					if(i==maxdate) {
						System.out.println();
									}
				}
			}
		}catch(ParseException e) {
			e.printStackTrace();
			}
			
			}
	}
	88.file：文件和目录类操作
	import java.io.File;
import java.io.IOException;
import java.io.FileReader

public class file01 {
	public static void printfile(File file,int lenve)  {
		for(int i=0;i<lenve;i++) {
			System.out.print("@");
		}
		System.out.println(file.getName());
		if(file.isDirectory()) {
			File[] files=file.listFiles();
			for(File temp:files) {
				//递归
				printfile(temp,lenve+1);
			}
		}
	}
	
	public static void main(String [] args) throws IOException {
		File f=new File("D:/123/456.txt");
		File f1=new File("D:/123");
		//判断是否为文件
		if(f.isFile()) {
			System.out.println("是一个文件");
		}
		//判断是否为目录
		if(f1.isDirectory()) {
			System.out.println("是一个目录");
		}
		//创建文件夹
		File f2=new File("D:/123/test123.java");
		f2.createNewFile();
		f2.delete();
		
		//创建目录
		File f3=new File("d:/123/aa/bb/cc");
		f3.mkdir();
		//树状形式打印文件夹
		File f4=new File("d:/123");
		printfile(f4,0);
	}
}
89.         &&&&&&&&&&& 异常机制（exception）&&&&&&&&&&
为什么需要异常：
1.如果没有会造成：逻辑代码和处理代码放在一起
2.程序员要对所有例外的情况都有l考虑，难度较大
常见的异常：
用户输入错误
设备错误
硬件问题
物理限制
磁盘满了
异常分为：编译器检查异常和编译器未检查异常
常见的异常有：空指针异常   class wang{
	public void print() {
		System.out.println("异常举例");
	}
}
public class exceptionour {
	public static void main(String [] args) {
		wang a=null;
		a.print();
	}
}
文件读取异常
数字格式异常：字符和数字混搭
类异常
处理异常和捕获异常
第一种：try{

}catch(Exception e){
																												<tag>//可以捕获多个异常，可以有多个catch语句，但是子类放在前面，父类放下面</tag>
}finally{
	//通常放关闭的代码
}//如果没有异常只执行try和finally 
	//如果有异常执行try 和finally
//finally语句可有可无，但是catch 不一定


import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class exceptionour {
	public static void main(String [] args) {
		FileReader reader=null;
		try {
			
		reader=new FileReader("d:/123/456.txt");
		char c1=(char)reader.read();
		char c2=(char)reader.read();
		System.out.println(c1);
		System.out.println(c2);
		System.out.println(""+c1+c2);
		}catch(FileNotFoundException e) {
			e.printStackTrace();
		}catch(IOException e){
			e.printStackTrace();
		}finally {
			try {
				if(reader==null)
				reader.close();
			}catch(Exception e) {
				e.printStackTrace();
			}
		}
		}
}
执行顺序
先执行try，catch，并且给返回值，但是暂时不作为最终的返回结果
在执行finally
再给返回值


第二种：throws:抛出并申明异常，自己不处理异常，让调用者处理，也叫检查时异常，当于其他的外界类产生联系的时候把异常抛给它来处理
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class exceptionour {
	public static String return1() throws FileNotFoundException,IOException  {
			FileReader reader=null;
			reader=new FileReader("d:/123/456.txt");
			char c1=(char)reader.read();
			char c2=(char)reader.read();
			System.out.println(c1);
			return "wang";
			
	
	}	
	public static void main(String [] args) {
		try {
				return1();
			}catch(FileNotFoundException e) {
				e.printStackTrace();
			}catch(IOException e){
				e.printStackTrace();
			}finally {
				System.out.println("finally");
		
			}
		}
}
申明异常的原则：
父类中没有申明异常，子类也不可以申明异常                                           （有继承关系的时候先子类后父类）
子类中申明的异常也得是父类申明异常本身或者是父类异常的子类
抛出异常的类型不可以比原有方法抛出的异常类型更多（这里指的不是个数）
import java.io.FileNotFoundException;
import java.io.IOException;

class A{
	public void print()throws IOException{
	}
}
class B extends A {
	public void print() throws FileNotFoundException {
		//是父类异常的子类所以可以执行
	}
}
class C extends A{
	public void print() throws Exception{
	//报错的原因是：该类异常不是父类异常的子类
	}
}

public class testextends {

}
第三种：手动抛出异常，用throw（throw new 一个新的对象）

自定义异常：
import java.io.IOException;

//自定义类
public class myexception extends  Exception {
	public myexception() {
		
	}
	public myexception(String message) {
		super(message);
		
	}
}
class testmyexception{
	void test() throws myexception{
	}
	public static void main(String[] args) {
		try {
			new testmyexception().test();
		} catch (myexception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}														//public static void main(String [] args){
																																																	}	可以不在public类中执行			

使用建议：
避免使用异常处理代替错误处理
不要进行小的力度的异常处理
异常往往在高层处理

90.  *****************************容器的相关知识*****************************
什么是容器：就像一个篮子可以添加各种各样的的对象（列如数组）
四大接口： collection接口（有set和list两大子接口）          set接口（数据对象没有顺序并且不可以重复）  list接口 （数据对象有顺序并且可以重复）  map接口定义了健和值对应的映射方法
Map.Entry的定义。Map的entrySet()方法返回一个实现Map.Entry接口的对象集合。集合中每个对象都是底层Map中一个特定的键/值对。
容器的实现有链表（linked）和数组（arraylist）形式
list接口一般需要用到的子类有三个：
1.arraylist：是用数组的形式实现的，线程不安全，所以查询快，删除，增加，修改慢
2.linkedlist：使用链表来实现的，线程不安全，所以查询慢，删除，增加，修改快
3.vector：用数组来实现的，线程安全
数组的实现代码：
package collection1;
import java.util.Scanner;

//自己实现arraylist，体会底层实现
 class myarraylist {
	private Object[] elementDate;
	private int size;
	//构造器
	public  myarraylist() {
		this(10);
	}
	public  myarraylist(int initialcapacity) {
		if(initialcapacity<0) {
			try {
				throw new Exception();
			}catch(Exception e) {
				e.printStackTrace();
			}
		}
		elementDate=new Object[initialcapacity];
	}
	//得到对象
	public Object get(int index) {
		if(index<0||index>size) {
			try {
				throw new Exception();
			}catch(Exception e) {
				e.printStackTrace();
			}
		}
		return elementDate[index];
	}
	
	
	
	
	
	
	
	//装对象，增加对象
	public void add(Object obj) {
		if(size==elementDate.length){
			Object[] newelementDate=new Object[size*2+1];
			System.arraycopy(elementDate, 0, newelementDate, 0, elementDate.length);
			elementDate=newelementDate;
		}
		elementDate[size]=obj;
		size++;
	}
	
	
	//删除相同的对象，通过对象索引
	public void remove(Object obj) {
		if(obj==null) {
			System.out.println("容器中没有此对象");
		}else {
			for(int i=0;i<size;i++) {
				if(elementDate[i]==obj) {
					remove1(i);
					i=0;
					}
				}
			}
		}
	
	//删除对象，通过位置索引
	public void remove1(int index) {
		if(index<0||index>size) {
			try {
				throw new Exception();
			}catch(Exception e) {
				e.printStackTrace();
			}
		}
		for(int i=index;i<size;i++) {
			elementDate[i]=elementDate[i+1];
		}
		elementDate[size]=null;
		size--;
		
	}
	
	//修改对象
	public void  change(Object obj) {
		int k=0;
		Scanner sca=new Scanner(System.in);
		if(obj==null) {
			System.out.println("对象为空");
		}else {
			for(int i=0;i<=elementDate.length;i++) {
				k++;
				if(elementDate[i]==obj) {
					elementDate[i]=sca.nextLine();
					return;
				}
			}
			if(k==elementDate.length) {
				System.out.println("该对象不存在");
			}
		}
	}
	public int size() {
		return size;
	}
	public Object getobj(int index) {
		if(index<0||index>size) {
			try {
				throw new Exception();
			}catch(Exception e) {
				e.printStackTrace();
			}
		}
		return elementDate[index];
		
	}
	

	public static void main(String [] args)  {
		myarraylist list=new myarraylist();
		//向容器里添加对象
		list.add("王思伟3");
		list.add("王思伟3");
		list.add("王思伟3");
		list.add("王思伟3");
		list.add("王思伟3");
		list.add("王思伟3");
		list.add("王思伟3");
		
		
		//修改对象
		//list.change("王思伟1");
		//list.change("王思伟2");
		String str=(String)list.getobj(0);
		String str1=(String)list.getobj(1);
		
		//System.out.println(str);
		//System.out.println(str1);
		
		//删除对象
		list.remove("王思伟3");
		System.out.println(list.get(1));
		list.remove("王思伟3");
		//list.change("王思伟2");
		//list.remove("王思伟3");
		//list.remove1(2);
		//System.out.println(list.size());
		//String str2=(String)list.getobj(3);
		System.out.println(list.size);
		//System.out.println(str2);
	}
}
链表的实现：
package collection1;
class Node{
	public  Node present;
	public Object now;
	public Node next;
}
public class linklist {
	private Node first;
	private Node last;
	private int size;
	
	//增加节点，向里面对象
	public void add(Object obj) {
		if(first==null) {
			Node n=new Node();
			n.present=null;
			n.now=obj;
			n.next=null;
			first =n;
			last=n;
		}else {
			Node n1=new Node();
			n1.present=last;
			n1.now=obj;
			n1.next=null;
			last.next=n1;
			last=n1;
			
		}
		size++;
	}
	//返回链表的长度
	public int getsize() {
		return size;
	}
	
	//得到链表对象
	public Object getobj(int index) {
		if(index>size||index<0) {
			try {
				throw new Exception();
			}catch(Exception e) {
				e.printStackTrace();
			}
			return "kong";
		}else {
				Node temp=first;
				for(int i=0;i<index;i++){
					temp=temp.next;
				}
				return temp.now;
		}
	}
	
	//特定位置增加一个节点
	public void add1(int index,Object obj) {
		if(index>size||index<0) {
			try {
				throw new Exception();
			}catch(Exception e) {
				e.printStackTrace();
			}
		}else {
			Node temp=first;
			for(int i=0;i<index-1;i++){
				temp=temp.next;
			}
			Node temp1=new Node();
			temp1.next=temp.next;
			temp.next.present=temp1;
			temp1.present=temp;
			temp.next=temp1;
			temp1.now=obj;
			size++;
		}
	}
	//删除具体位置的节点,头和尾除外
	public void delete(int index) {
		if(index>size||index<0) {
			try {
				throw new Exception();
			}catch(Exception e) {
				e.printStackTrace();
			}
		}else {
			Node temp=first;
			for(int i=0;i<index;i++) {
				temp=temp.next;
			}
			temp.present.next=temp.next;
			temp.next.present=temp.present;
			size--;
		}
		
	}
	//删除容器头结点
	public void delete1() {
		first=first.next;
		first.present=null;
		size--;
	}
	//删除容器尾结点
	public void delete2() {
			Node temp=first;
			for(int i=0;i<size-1;i++) {
				temp=temp.next;
			}
			temp.next=null;
			last=temp;
			size--;
		
	}
	//容器的遍历
	public void print() {
		for(int i=0;i<size;i++)
			System.out.println((String)getobj(i));
	}
	
	//修改容器中的数据
	public void change(int index,Object obj) {
		if(index>size||index<0) {
			try {
				throw new Exception();
			}catch(Exception e) {
				e.printStackTrace();
			}
		}else {
			Node temp=first;
			for(int i=0;i<index;i++) {
				temp=temp.next;
			}
			temp.now=obj;
		}
	}
	public static void main(String [] args) {
		linklist l=new linklist();
		l.add("王思伟1");
		l.add("王思伟2");
		l.add("王思伟4");
		l.add1(2, "王思伟3");
		l.change(0, "王思伟5");
		l.print();
		System.out.println(l.getsize());
	}
}
map接口的实现：map的键不可以重复，重复的话会覆盖值，解决问题的方法是哈希表，通过数组加链表的形式来解决键值相同的问题。
package collection1;
//实现map，通过键来找值
class array{
	Object key;
	Object value;
	public array(Object key,Object value) {
		this.key=key;
		this.value=value;
	}
}
public class maplist {
	linklist[] map=new linklist[99999];
	int size;
	
	//放键和值,map的底层实现是数据加链表的形式
	public void put(Object key,Object value) {
		array e=new array(key,value);
		int a=-key.hashCode()%map.length;
		if(map[a]==null) {
			linklist list=new linklist();
			map[a]=list;
			list.add(e);
		}else {
			map[a].add(e);
		}
	}
	//通过键查找值
	public void find(Object key) {
		int a=-key.hashCode()%map.length;
		if(map[a]!=null) {
			linklist list=map[a];
			for(int i=0;i<list.getsize();i++) {
				array e=(array)list.getobj(i);
				if(e.key==key) {
					System.out.println("键值为:"+e.value);
				}
			}
		}else {
			System.out.println("查找的键不存在");
		}
	}
	
	//修改键值
	public void change(Object key,Object value) {
		int a=-key.hashCode()%map.length;
		if(map[a]==null) {
			System.out.println("所要修改的键值不存在");
		}else{
			linklist list=map[a];
			for(int i=0;i<list.getsize();i++) {
				array e=(array)list.getobj(i);
				if(e.key==key) {
					e.value=value;
					System.out.println("修改后的键值为:"+e.value);
				}
			}
			
		}
	}
	//通过键删除键和值
	public void delete(Object key) {
		int a=-key.hashCode()%map.length;
		if(map[a]==null) {
			System.out.println("要删除的键值不存在");
		}else {
			linklist list =map[a];
			for(int i=0;i<list.getsize();i++) {
				array e=(array)list.getobj(i);
				if(e.key==key) {
					list.delete(i);
				}
			}
		}
		
	}
	//打印键值
	public void print() {
	
	}
	
	public static void main(String [] args) {
		maplist m=new maplist();
		m.put("201712058", "王思伟");
		m.put("201712059", "王那那");
		m.put("201712060", "王晓二");
		m.change("201712058", "王思伟23");
	}
}
Java中每个对象都有对应的哈希值，两个想等的对象具有相同的哈希值
equal方法比较的是对象是否相同，==比较的是对象是否相等
哈希值相等，equal返回的不一定是true
equal返回的是true，哈希值一定相等
hashCode是所有java对象的固有方法，如果不重载的话，返回的实际上是该对象在jvm的堆上的内存地址，而不同对象的内存地址肯定不同，所以这个hashCode也就肯定不同了。如果重载了的话，由于采用的算法的问题，有可能导致两个不同对象的hashCode相同。

javaBean类是一个只有属性和get和set方法的类，属于简单类
class employee{          //只有属性和构造方法 javaBean类

	private int id;
	private String name;
	private int salary;
	private String bumeng;
	private Date hiretime;
	public employee(int id,String name,int salary,String bumeng ,String hiretime) throws ParseException {
		this.id=id;
		this.name=name;
		this.salary=salary;
		DateFormat str=new SimpleDateFormat("yyyy--MM");
		this.hiretime=str.parse(hiretime);
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getSalary() {
		return salary;
	}
	public void setSalary(int salary) {
		this.salary = salary;
	}
	public String getBumeng() {
		return bumeng;
	}
	public void setBumeng(String bumeng) {
		this.bumeng = bumeng;
	}
	public Date getHiretime() {
		return hiretime;
	}
	public void setHiretime(Date hiretime) {
		this.hiretime = hiretime;
	}
	
}


***************迭代器iterator接口来实现，程序开发通常通过迭代器来对集合进行遍历*****************
package fanxing;
import java.util.Iterator;
/**迭代器的作用避免程序运行开销，当我们遍历容器的时候，
我们多次便利时不用再次创建一个容器，我们只需要再次调用容器中的一个方法
*/
public class myarraylist {
	private String [] map= {"a","b","c","d","e","f"};
	private int size=map.length;
	
	/**
	 * 实现迭代器用内部类的实现方式
	 * @author 王思伟
	 *
	 */
	private class list implements Iterator<String>{
	private int cousor=-1;
	
	
	
	//判断是否有下一个
	public boolean hasNext() {
		return cousor<size-1;
	}
	//获取下一个元素
	public String next() {
		cousor++;
		return map[cousor];
	}
	
	
	}
	public Iterator<String> print(){
		return new list();
	}
	public static void main(String [] args) {
		myarraylist l=new myarraylist();
		Iterator<String> l1=l.print();
		while(l1.hasNext()) {
			System.out.println(l1.next());
			
		}
		
		
		Iterator<String> l2=l.print();
		while(l2.hasNext()) {
			System.out.println(l2.next());
		}
	}
	
}




package fanxing;
import java.util.Iterator;
/**迭代器的作用避免程序运行开销，当我们遍历容器的时候，
我们多次便利时不用再次创建一个容器，我们只需要再次调用容器中的一个方法
*/
public class myarraylist {
	private String [] map= {"a","b","c","d","e","f"};
	private int size=map.length;
	
	/**
	 * 使用匿名内部类来实现
	 * @return
	 */
	public Iterator<String> print(){
		return new Iterator()
				{
				private int cousor=-1;
				//判断是否有下一个
				public boolean hasNext() {
					return cousor<size-1;
				}
				//获取下一个元素
				public String next() {
					cousor++;
					return map[cousor];
				}
		};
	}
	public static void main(String [] args) {
		myarraylist l=new myarraylist();
		Iterator<String> l1=l.print();
		while(l1.hasNext()) {
			System.out.println(l1.next());
			
		}
		Iterator<String> l2=l.print();
		while(l2.hasNext()) {
		
		
			System.out.println(l2.next());
		}
	}
	
}
遍历容器也可以使用增强for
增强for必须实现java.lang.Iterable接口，重写iterator方法



*********************泛型的相关知识*********************
泛型无多态
泛形要求能包容的是对象类型，而基本类型在java里不属于对象
使用泛型的原因：当使用object 发生多态的时候需要：强制类型转化，手动类型检查防止转化错误
泛型的作用：在编译的时候自动类型检查，所有的强制转化都是自动的和隐式的，可以提高代码的复用率
泛型是使用时指定类型，只能是引用类型***，因为泛型要求包容的是对象类型，基本数据类型不是对象
泛型不能使用在静态属性和静态方法中，因为静态方法和静态属性是在编译时确定，而我们是要在使用时确定类型，所以如果使用会报错


*****通配符***
package fanxing;
//泛型没有多态
//通配符
//？使用：可以在声明类型及声明方法参数上使用，不能用在声明类上或者使用时
//可以接受泛型的任意类型，只能被接受和输入不能修改
//? extends<= 指定的类型是子类或者自身
//？super>= 指定的类型是自身或者父类
public class friut<T>{
	T name;
	public static void main(String [] args) {
		//friut<?> f=new friut<?>();//报错因为只能使用在声明上
		friut<?> f=new friut<String>();
		test2(new friut());
		test2(new friut<wei>());//报错声明的类型只能是子类或则本身
		
		test3(new friut());
		test3(new friut<wei>());
		
	}
	public static void test(friut<?> a) {
		
	}
	public static void test1(friut<String> f) {
		//指定的类型可以的
	}
	
	public static void  test2(friut<? extends si> f) {
		
	}
	public static void test3(friut<? super si> f) {
		
	}
}
class wei{
	
}
class si extends wei{
	
}
class wang extends si{
	
}


******泛型的嵌套*****
package fanxing;

public class ll<T> {
	T i;
	public static void  main(String [] args) {
		//泛型的嵌套
		ll<friut<String>> l=new ll<friut<String>>();
		//从外到内拆分
		l.i=new friut<String>();
		friut<String> str=l.i;
		str.name="王思伟";
		String str1=str.name;
		System.out.println("姓名为:"+str1);
		
		
		
	}
}
****泛型与数组******
没有泛型数组，不能创建泛型数组
可以使用？声明
package fanxing;
public class ww {
	public static void main(String[] args) {
		Integer[] arr=new Integer[10];
		//friut<String>[] arra=new friut<String>[10];//后面报错，声明可以用，使用不可以
		friut<?>[] wei=new friut[10];//不报错，问号只可以用在声明的时候
		arraylist<String> array=new arraylist<String>();
		array.add(0, "a");
		String str=array.get(0);//这里的对象类型自动转化为我们用的泛型了
		System.out.println(str);
	}

}
class arraylist<T>{
	//T [] map=new T[10];报错，没有泛型数组，但是可以通过泛型类来实现类型是泛型的数组，通过Object类来实现
	Object[] map=new Object[10];
	public void add(int index,T t) {
		map[index]=t;
	}
	public T[] getall() {
		return (T[])map;
	}
	public T get(int index) {
		return (T)map[index];
	}
}
jdk1.7之后中使用泛型
声明时需要指定泛型，使用时不需要指定泛型








public class iterator<type> {
	private type javascore;
	private type oricale;
	public type getJavascore() {
		return javascore;
	}
	public void setJavascore(type javascore) {
		this.javascore = javascore;
	}
	public type getOricale() {
		return oricale;
	}
	public void setOricale(type oricale) {
		this.oricale = oricale;
	}
	public static void main(String [] args) {
		//在使用时指定类型，而且只能是引用类型
		//iterator<int> w=new iterator<int>();所以报错
		iterator<Integer> w=new iterator<Integer>();//所以不报错
	}
}
在接口中泛型只能使用在方法中，不可以使用在全局常量中，因为全局常量是静态的，在编译时确定
//泛型接口
interface wang<T>{
	T i;//报错的
	void print(T i);//不报错
}








****泛型类****：
package collection1;
/**
父类类为泛型
属性类型
父类中随父类而定
子类中随子类而定
方法类型
方法类型随父类而定
要么同时擦除，也就是说子类指定类型大于等于父类类型


泛型接口和泛型类同理
*/
abstract class father<T>{
	T NAME;
	abstract void print(T i);
	
}
/**、
 * 
 * 子类声明时指定具体类型
 * 子类属性用具体的类型
 *
 */
class child1 extends father<String>{
	String name;

	@Override
	void print(String i) {
		// TODO Auto-generated method stub
	}	
}
/**
 * 
 * 子类为泛型类，父类指定类型，在使用时指定类型
 * 
 *
 */
class child2<T> extends father<T>{
	T name;
	@Override
	void print(T i) {
		// TODO Auto-generated method stub	
	}
	
}
/**
 * 
 * 子类为泛型类，父类不指定类型,泛型类的擦除，使用Object来替换
 *
 */
class child3<T> extends father{
	
	@Override
	void print(Object i) {
		// TODO Auto-generated method stub
	}
	
	
}
/**
 * 
 *父类和子类同时擦除，使用Object来替换
 *
 */
class child4 extends father{

	@Override
	void print(Object i) {
		// TODO Auto-generated method stub
	}
	
}
public class www {

}
***泛型的擦除****：
继承的时候：实现和声明不指定类型
在使用的时候也不指定类型，统一使用Objectl来对待
擦除不会类型检查



***泛型方法***：
只能访问对象的信息，不能修改对象的信息，因为和类型的确定有关系
public static <t> void print(t j) {
		//泛型方法：格式是将泛型放在修饰符和返回类型的中间
	}
	
	
	接口和抽象类：
	抽象类不可以创建对象
	但是接口在特殊的情况下可以创建对象，而且接口存在的意义时实现java多态机制，java规定接口interface不能直接使用new关键字来创建对象，
	但是并没有限定他不能创建对象，接口可以使用匿名方式创建对象
	
****hashmap的经典储存*****
package jier;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class maplist1 {
	public static void main(String [] args) {
	List<Student> list=new ArrayList<Student>();
	exam(list);
	
	
	Map<String,Classroom> rooms=new HashMap<String,Classroom>();
	count(rooms,list);
	
	printscore(rooms);
	}
	/**
	 * 统计分数
	 */
	
	public static void count(Map<String,Classroom> rooms,List<Student> list) {
		for(Student stu:list) {
			String no=stu.getNo();
			double score=stu.getScore();
			Classroom room=rooms.get(no);
			if(null==room) {
				room=new Classroom(no);
				rooms.put(no, room);
			}
			room.setTotal(room.getTotal()+score);
			room.getStu().add(stu);
		}
	}
	/**
	 * 将学生丢进list里
	 * @param list
	 */
	public static void exam(List<Student> list){
		list.add(new Student("王思伟","001",90));
		list.add(new Student("王晓伟","002",95));
		list.add(new Student("王二伟","003",90.5));
		list.add(new Student("王小伟","004",80));
		list.add(new Student("王一伟","003",80));
		
		
	}
	/**
	 * 打印分数
	 */
	public static void printscore(Map<String,Classroom> rooms) {
		Set<Map.Entry<String,Classroom>> entryset=rooms.entrySet();//泛型的嵌套
		Iterator<Map.Entry<String,Classroom>> it= entryset.iterator();
		while(it.hasNext()) {
			Map.Entry<String,Classroom> entry=it.next();
			Classroom room=entry.getValue();
			double avg=room.getTotal()/room.getStu().size();
			System.out.println("班号为:"+room.getNo()+",总分为:"+room.getTotal()+",平均分为:"+avg);
		}
	}
}


91*******引用类型比较********
方法有两种：
1.需要实体类实现java.lang.comparable接口
2.需要业务类实现java.util.comparator接口

列如对新闻的排序用comparable接口来实现（实体类来实现）
****容器中使用toString返回的是容器对象的输出***
package New;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 *对网页新闻进行排序
 * @author 王思伟
 *
 */
public class Newart  implements java.lang.Comparable<Newart>{
	//新闻标题
	private String title;
	//新闻点击量
	private int number;
	//新闻时间
	private Date puttime;
	public Newart(String title,int number,Date puttime) {
		this.title=title;
		this.number=number;
		this.puttime=puttime;
	}
	//先按时间降序，再按点击量升序，在按标题降序
	@Override
	public int compareTo(Newart o) {
		//定义一个返回值，默认为0
		int result=0;
		//先比较时间
	result=-this.puttime.compareTo(o.puttime);
	if(result==0)//如果时间相同
		{
		result=this.number-o.number;
		if(0==result) //如果点击量相同
		{
			result=-this.title.compareTo(o.title);
		}
	}
		return result;
	}
	public String getTitle() {
		return title;
	}
	public void setTitle(String title) {
		this.title = title;
	}
	public int getNumber() {
		return number;
	}
	public void setNumber(int number) {
		this.number = number;
	}
	public Date getPuttime() {
		return puttime;
	}
	public void setPuttime(Date puttime) {
		this.puttime = puttime;
	}

	@Override
	public String toString() {//对tostring方法进行重写，tostring方法是为了便于对输出，会调用相应的类的toString方法
	StringBuilder sb=new StringBuilder();
	sb.append("标题为:").append(title);
	sb.append("点击量为:").append(number);
	sb.append("时间为:").append(new SimpleDateFormat("yyyy--MM--dd").format(puttime)).append("\n");
	return sb.toString();
	}
}


package New;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;

public class test1 {
	public static void main(String [] args) {
		List<Newart> list= new ArrayList<Newart>();
		list.add(new Newart("王思伟成为世界首富    ",20000000,new Date(System.currentTimeMillis()+1000*60*60)));
		Collections.sort(list);
		list.add(new Newart("中国登上钓鱼岛，全国欢庆   ",200000,new Date(System.currentTimeMillis()-1000*60*60)));
		list.add(new Newart("小马云的诞生    ",20000,new Date()));
		System.out.println(list);
		System.out.println(list);
	}
}

对淘宝商品的排序comparator接口来实现（业务类来实现的）
package New;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**测试排序
 * 
 * @author 王思伟
 *
 */
public class goodapp {
	public static void main(String [] args) {
		List<goode> list=new ArrayList<goode>();
		list.add(new goode(5000,8000,"华硕电脑游戏精灵"));
		list.add(new goode(7000,6000,"惠普电脑超薄本"));
		list.add(new goode(10000,9000,"苹果电脑豪华版加贵族版"));
		list.add(new goode(5500,7000,"戴尔电脑迷你"));
		list.add(new goode(6000,3000,"联想电脑新"));
		System.out.println("********按价格排序*************");
		Collections.sort(list, new goodecom());//通过价格业务类排序实现
		System.out.println(list);
		System.out.println("**********按收藏量排序**********");
		Collections.sort(list, new goodecom1());//通过收藏量业务类排序实现
		System.out.println(list);
		System.out.println("********按名字来排序*********");
		Collections.sort(list, new goodecom2());//通过名字业务类排序来实现
		System.out.println(list);
	}

}




引用数据类型的比较规则：
相等返回0
大于返回正数
小于返回负数
package fanxing;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
/**
 * ********实现Comparable接口对数组及容器进行排序******
 * @author 王思伟
 *
 */
public class paixu {
	//对数组的排序，通用方法
	public static void sort(Object [] str) {
		for(int i=0;i<str.length-1;i++) {
			for(int j=0;j<str.length-1-i;j++) {
				if(((Comparable)str[j]).compareTo(str[j+1])>0) {
					Object temp=str[j+1];
					str[j+1]=str[j];
					str[j]=temp;
				}
			}
		}
	}
	
	
	//使用泛型对数组排序
	public static  <T extends Comparable<T>>void sort1(T [] str){
		for(int i=0;i<str.length-1;i++) {
			for(int j=0;j<str.length-1-i;j++) {
				if(((Comparable)str[j]).compareTo(str[j+1])>0) {
					T temp=str[j+1];
					str[j+1]=str[j];
					str[j]=temp;
				}
			}
		}
	}
	//使用泛型对容器进行排序
	public static  <T extends Comparable<T>>void sort2( List<T> list){
		Object [] arr=list.toArray();
		sort(arr);
		for(int i=0;i<arr.length;i++) {
			list.set(i, (T)arr[i]);
		}
		
	}
	
	public static void main(String [] args) {
		String[] str= {"abc","a","bca","abcd"};
		boolean sorted=true;	
		//从小到大排列
		for(int i=0;i<str.length-1;i++) {
			for(int j=0;j<str.length-1-i;j++) {
				if(((Comparable)str[j]).compareTo(str[j+1])>0) {
					String temp=str[j+1];
					str[j+1]=str[j];
					str[j]=temp;
					sorted=false;
				}
			}
		}
		System.out.println(Arrays.toString(str));
		
		List<String> list=new ArrayList<String>();
		list.add("abc");
		list.add("a");
		list.add("bca");
		list.add("abcd");
		sort2(list);
		System.out.println(list.toString());
	}
}


**********comparator接口实现对数组和容器的排序******
重写的comparator接口
package Comparator;

import java.util.List;
import java.util.Arrays;

public class Comparator1 implements java.util.Comparator<String> {
	/**
	 * 通过长度对字符串进行比较大小
	 */
	public int compare( String q1, String q2) {
		int length1=q1.length();
		int length2=q2.length();
		return length1-length2;
	}
}


package Comparator;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class test {
	public  static <T> void sort(Object[] str,Comparator1 com) {
		for(int i=0;i<str.length-1;i++) {
			for(int j=0;j<str.length-1-i;j++) {
				if(com.compare((String)str[j],(String)str[j+1])>0) {
					Object temp=str[j+1];
					str[j+1]=str[j];
					str[j]=temp;
				}
			}
		}
		
	}
	/**
	 * 使用Comparator接口对list进行排序
	 * @param args
	 */
	public static<T> void sort2(List<T> list ,Comparator1 com) {
		Object [] arr=list.toArray();
		sort(arr,com);
		for(int i=0;i<arr.length;i++) {
			list.set(i, (T)arr[i]);
		}
		
	}
	public static void main(String [] args){
		List<String> list=new ArrayList<String>();
		list.add("abcd");
		list.add("abd");
		list.add("abcde");
		list.add("ab");
		sort2(list,new Comparator1());
		System.out.println(list);
		Collections.sort(list);
		System.out.println(list);
	}
}
comparable接口是通过实体类来实现排序
comparator接口是通过独立于实体类的业务类来实现排序
实体类：拥有set和get方法的类叫做实体类

treemap和treeset是可以排序的容器类
treeset可以排序且元素不可以重复，是set接口的实现类,在添加数据时排序，在使用的过程中不要修改数据，会造成数据的重复。可以用final修饰
package newpac;


/**业务类
 * 用comparator接口实现的可排序容器TreeSet
 */
 
 
import java.util.TreeSet;

public class tresetmao {
	public static void main(String [] args) {
		person p1=new person("王思伟",100);
		person p2=new person("王晓伟",10);
		person p3=new person("王大伟",30);
		person p4=new person("王二伟",20);
		person p5=new person("王三伟",50);
		//匿名内部类来重写compare方法，添加一个业务类
		TreeSet<person> set=new TreeSet<person>(new java.util.Comparator<person>() {
			@Override
			public int compare(person o1, person o2) {
				//降序排列
				return -(o1.getHandsome()-o2.getHandsome()>0?1:o1.getHandsome()-o2.getHandsome()==0?0:-1);
			}
		});
		//TreeSet在添加数据过程中进行排序
		set.add(p1);
		set.add(p2);
		set.add(p3);
		set.add(p4);
		set.add(p5);
		System.out.println(set);
	}

}


package newpac;
/**实体类实现
 * comparable接口实现可排序的容器类TreeSet
 * @author 王思伟
 *
 */
public class workers implements java.lang.Comparable<workers>{
	//工资
	private int salary;
	//工种
	private String department;
	public workers() {
		
	}
	public workers(int salary, String department) {
		super();
		this.salary = salary;
		this.department = department;
	}
	public int getSalary() {
		return salary;
	}
	
	
	public void setSalary(int salary) {
		this.salary = salary;
	}
	public String getDepartment() {
		return department;
	}
	public void setDepartment(String department) {
		this.department = department;
	}
	@Override
	public String toString() {
		return "工种为:"+department+"  工资为"+salary+"\n";
	}
	@Override
	//按工资降序
	public int compareTo(workers o) {
		
		return -(salary-o.salary>0?1:salary-o.salary==0?0:-1);
	}

	

}

set接口的实现类hashset，元素必须重写hashcode和equals方法
1.元素可以排序 java,lang.coparable+comparato
构造器：new treeset();
2.排序业务类:java.util.comparator+compare
构造器：new treeset(omparator<? super  t>comparator)


treemap可实现排序的容器类
package newpac;
/**
 * ********用业务类来实现可排序的容器类TreeMap*****
 */
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

public class test03 {
		public static void main(String [] args) {
			personmap p1=new personmap("王思伟",100);
			personmap p2=new personmap("王晓伟",10);
			personmap p3=new personmap("王大伟",30);
			personmap p4=new personmap("王二伟",20);
			personmap p5=new personmap("王三伟",50);
			//匿名内部类来重写compare方法，添加一个业务类
			TreeMap<personmap,String> set=new TreeMap<personmap,String>(new java.util.Comparator<personmap>() {
				@Override
				public int compare(personmap o1, personmap o2) {
					//降序排列
					return -(o1.getHandsome()-o2.getHandsome()>0?1:o1.getHandsome()-o2.getHandsome()==0?0:-1);
				}
			});
			set.put(p1, "wangsiwei");
			set.put(p2, "wangsiwei");
			set.put(p3, "wangsiwei");
			set.put(p4, "wangsiwei");
			set.put(p5, "wangsiwei");
			System.out.println(set);
			Set<personmap> s=set.keySet();
			System.out.println(s);
			
		}
}



package newpac;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 * ******实体类来实现可排序的容器类treemap******
 * @author 王思伟
 *
 */
public class test04 {
	public static void main(String [] args) {
		workers w=new workers(10000,"程序员");
		workers w1=new workers(8000,"垃圾整理员");
		workers w2=new workers(6000,"农名工");
		workers w3=new workers(4000,"打字员");
		TreeMap<workers,String> employees=new TreeMap<workers,String>();
		employees.put(w, "wanghsiwe");
		employees.put(w1, "wanghsiwe");
		employees.put(w2, "wanghsiwe");
		employees.put(w3, "wanghsiwe");
		Set<workers> s=employees.keySet();
		System.out.println(s);
	}
}
collection接口相应的方法
模拟斗地主洗牌
package New;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class doudizhu {
	public static void main(String [] args) {
		List<Integer> list=new ArrayList<Integer>();
		//先给容器所有的牌，一共54张
		for(int i=0;i<54;i++) {
			list.add(i);//使用了自动装箱
		}
		//对扑克进行洗牌
		Collections.shuffle(list);
		List<Integer> p1=new ArrayList<Integer>();//第一个人的牌
		List<Integer> p2=new ArrayList<Integer>();//第二个人的牌
		List<Integer> p3=new ArrayList<Integer>();//第三个人的牌
		List<Integer> last=new ArrayList<Integer>();//最后三张底牌
		//然后依次发牌
		for(int i=0;i<51;i+=3) {
			p1.add(list.get(i));
			p2.add(list.get(i+1));
			p3.add(list.get(i+2));
		}
		//留最后三张牌
		last.add(51);
		last.add(52);
		last.add(53);
		System.out.println("第一个人的牌:"+p1);
		System.out.println("第二个人的牌:"+p2);
		System.out.println("第三个人的牌:"+p3);
		System.out.println("最后三张底牌:"+last);
	}
}
第一个人的牌:[23, 38, 4, 48, 15, 31, 47, 37, 42, 22, 19, 43, 28, 52, 40, 0, 13]
第二个人的牌:[17, 44, 46, 18, 25, 7, 8, 26, 1, 20, 11, 50, 39, 9, 5, 51, 34]
第三个人的牌:[41, 16, 36, 30, 6, 32, 29, 53, 14, 27, 2, 24, 21, 12, 3, 33, 45]
最后三张底牌:[51, 52, 53]

queue和deque（队列和双向队列）
使用单向队列实现银行存款业务
package queue;
import java.util.ArrayDeque;
import java.util.Queue;

/**
 * 队列模拟银行存款，在匿名类中接口时可以建立对象的
 * @author 王思伟
 *
 */
public class dome0 {
	public static void deal(Queue<requeue> q) {
		requeue req=null;
		while(null!=(req= q.poll())) {
				req.dipose();
		}
		
	}
	public static void main(String [] args) {
		Queue<requeue> q=new ArrayDeque<requeue>();
		//模拟排队情况
		for(int i=1;i<10;i++) {
			final int sum=i;
			//使用匿名内部类来实现
			q.add(new requeue() {

				@Override
				public void dipose() {
					System.out.println("第"+sum+"个人办理存款业务"+"  存款金额为:"+Math.random()*10000);
				}
			});
			
			deal(q);
		}
		
	}
}
//定义一个接口
interface requeue{
	//存款
	void dipose();
}


package queue;

import java.util.ArrayDeque;
import java.util.Deque;

/**
 * 用双向队列实现栈堆
 * 1.压栈
 * 2.弹栈
 * 3.获取
 * @author 王思伟
 *
 */
public class dequeue<E> {
	private Deque<E> que=new ArrayDeque<E>();
	private int cap;
	public dequeue(int cap) {
		this.cap=cap;
	}
	//压栈
	public boolean push(E e) {
		if(que.size()+1>cap) {
			return false;
		}
		return que.offerLast(e);
	}
	//弹栈
	public E pull() {
		return que.pollLast();
	}
	//获取
	public E peek() {
		return que.peekLast();
	}
	//大小
	public int size() {
		return que.size();
	}
	public static void main(String [] args) {
		dequeue<String> req=new dequeue<String>(10);
		req.push("王思伟");//1
		req.push("王思伟1");//2
		req.push("王思伟2");//3
		req.push("王思伟3");//4
		req.push("王思伟4");//5
		/*System.out.println(req.pull());
		System.out.println(req.pull());
		System.out.println(req.peek());
		System.out.println(req.size());
		*/
		//对栈进行遍历
		String temp=null;
		while(null!=(temp=req.pull())) {
			System.out.println(temp);
			
		}
	
	}
	
}
队列分为单向队列和双向队列
单项队列：一端操作
1.一般队列（先进先出）
2.优先队列堆栈（先进后出）
双向队列：两端操作

***********ennumeration接口是老的接口：用于对容器的遍历（和lterator相似，是enumeration的加强版）**************
一般常用的方法有两个：
hasMoreElements() 
测试此枚举是否包含更多元素。  
 nextElement()  



package enumeration;
import java.util.Enumeration;
import java.util.Vector;
/**
 * enumeration接口的使用
 * 1.判断
 * 2.获取
 * 
 * 学会vector中的elements（）方法
 * @author 王思伟
 *
 */
public class enumm {
	public static void main(String [] args){
		Vector<String> v=new Vector<String>();
		v.add("wangswiei");
		v.add("wangswiei1");
		v.add("wangswiei2");
		
		//遍历容器
		Enumeration<String> en=v.elements();
		//用到了enumeration的两个方法
		while(en.hasMoreElements()){
			System.out.println(en.nextElement());
			
		}
	}
}

*******enumeration的子类StringTokenizer 字符串的分割，可以使用弗雷德迭代器********
package enumeration;
import java.util.StringTokenizer;
/**enumeration的子类
 * StringTokenizer 字符串的分割，可以使用弗雷德迭代器
 * @author 王思伟
 *
 */
public class enumerate {
	public static void main(String args[]) {
		String wang="www.wangsiwei.com;www.wangsiowei.club;www.wangsiwei.con";
		StringTokenizer tokern=new StringTokenizer(wang,";");
		while(tokern.hasMoreElements()) {
			System.out.println(tokern.nextElement());
		}
	}
}
***************************hashmap和hashtable的不同点（他们都是map的实现类）*************************
1.hashmap和hashtable的父类不同：hashmap的父类是 AbstractMap<K,V>，hashtable的父类是 Dictionary<K,V>
2.hashtable的任何非null对象都可以用作键值或值，也就是键和值不能为空，hashmap的键和值可为空
3.hashmap是线程不安全的，hashtable是线程安全的
######hashtable的子类Properties：作用：读写资源配置文件，键和值只能是字符串#####
方法有：
getProperty(String key) 使用此属性列表中指定的键搜索属性。 
getProperty(String key, String defaultValue) 使用此属性列表中指定的键搜索属性。 
setProperty(String key, String value) 致电 Hashtable方法 put 。

package property;
import java.util.Properties;
/**
 * ********properties 资源配置文件******
 * @author 王思伟
 *
 */
public class dome1 {
	public static void main(String [] args){
		//创建对象，只能存储字符串，键和值只能是字符串
		Properties pro= new Properties();
		//存储
		pro.setProperty("王思伟", "世界首富");
		pro.setProperty("wangsiwei", "hahhah ");
		pro.setProperty("user", "scott");
		pro.setProperty("pwd", "tiger");
		//存在返回对应值，不存在返回默认值
		//获取
		String wangsiwei=pro.getProperty("wangsiwei","默认");
		System.out.println(wangsiwei);
		
	}
}
相对路径和绝对路径
 *绝对路径：盘符  非window用/
 *相对路径：当前的项目及工程
 package property;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;

/**
 * ********使用properties输出文件*******
 * 资源配置文件
 * 好处：可以随意化数据库，不需要改变代码
 * 两种格式：
 * properties格式：
 * pro.store();
 *xml格式：
 *pro.storeToXML();
 *相对路径和绝对路径
 *绝对路径：盘符  非window用/
 *相对路径：当前的项目及工程
 * @author 王思伟
 *
 */
public class 都么 {
	public static void main(String [] args) throws FileNotFoundException, IOException {
		//创建对象，只能存储字符串，键和值只能是字符串
				Properties pro= new Properties();
				//存储
				pro.setProperty("王思伟", "世界首富");
				pro.setProperty("wangsiwei", "hahhah ");
				pro.setProperty("user", "scott");
				pro.setProperty("pwd", "tiger");
				
			//存储到d:/others  绝对路径 带盘符的
			pro.store(new FileOutputStream(new File("d:/others/db.properties")), "db配置");
			pro.storeToXML(new FileOutputStream(new File("d:/others/db.xml")), "db配置");
			
			//使用相对路径，默认的是当前的工程下
			pro.store(new FileOutputStream(new File("db.properties")), "db配置");
			pro.storeToXML(new FileOutputStream(new File("db.xml")), "db配置");	
	}
}

package queue;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Properties;
/**
 * 使用properties读取配置文件
 * @author 王思伟
 *	**********使用相对于绝对路径读取文件*************
 */
public class 动么 {
	public static void main(String [] args) throws FileNotFoundException, IOException {
		Properties pro=new Properties();
		//读取绝对路径
		pro.load(new FileReader("d:/others/db.properties"));
		//读取相对路径
		pro.load(new FileReader("db.properties"));
		System.out.println(pro.getProperty("王思伟","12212"));
	}
}
************************************类路径加载资源文件*****************************
package property;
import java.io.IOException;
import java.util.Properties;

/**
 * ************使用类相对路径读取配置文件**************
 * bin（可以改变的）
 * @author 王思伟
 *
 */
public class dmoe4 {
	public static void main(String [] args) throws IOException {
		Properties pro=new Properties();
		//类相对路径 /表示bin目录
		pro.load(dmoe4.class.getResourceAsStream("/db.properties"));
		System.out.println(pro.getProperty("王思伟","12212"));
		//使用线程加载器 “”空表示bin目录
		pro.load(Thread.currentThread().getContextClassLoader().getResourceAsStream("property/db.properties"));
		System.out.println(pro.getProperty("王思伟","12212"));
	}
}
两种方式：
1.类名.class.getResourceAsStream("/")/表示bin目录
2.Thread.currentThread().getContextClassLoader().getResourceAsStream("")""空表示bin目录



*************************引用分类********************************
强引用：gc（java垃圾回收机制）运行时不回收
软引用：gc运行时可能不回收（jvm内存不够的时候回收）
弱引用：gc运行时立刻回收
虚引用：类似于无引用，主要跟踪对象被回收时的状态，不能单独使用，必须和引用队列联合使用
目的：避免对象长时间驻留在内存中，j解决垃圾回收机制回收问题

******对引用的管理******
package weak;
import java.lang.ref.WeakReference;
/**
 * 引用分类：强，软,弱，虚
 * 强与弱引用
 * @author 王思伟
 *
 */
public class weakmap {
	public static void main(String [] args) {
		//在堆中，不是字符串常量 ，会被回收
		String str=new String("wangsiwei  is good");
		WeakReference<String> vc=new WeakReference<String>(str);
		System.out.println("回收前:"+vc.get());
		//断开引用
		str=null;
		//通知回收
		System.gc();
		System.runFinalization();
		System.out.println("回收后:"+vc.get());
		
		
	}
	public static void teststrong() {
				//字符串放在字符串常量池中，为强引用,共享的，不回收
				String str="wangsiwei  is good";
				WeakReference<String> vc=new WeakReference<String>(str);
				System.out.println("回收前:"+vc.get());
				//断开引用
				str=null;
				//通知回收
				System.gc();
				System.runFinalization();
				System.out.println("回收后:"+vc.get());
	}
}
三个常用的引用类型接口：
1.weakhashmap键为弱引用
2.Identityhashmap键比较的是地址，而不是比较hashCode与equals
3.enumMap键要求为枚举的值



具体例子：
****************weakhashmap键为弱引用时，gc运行会被回收（）好处是：便于清理内存*******************
package weak;
import java.util.WeakHashMap;

/**
 * weakhashmap 键为弱引用类型，gc运行时立刻回收
 * @author 王思伟
 *
 */
public class weakmap1 {
	public static void main(String [] args) {
		WeakHashMap<String,String> map=new WeakHashMap<String,String>();
		//常量池对象是强引用不会回收
		map.put("abc", "a");
		map.put("abb", "1");
		//为堆中对象，gc运行会被回收
		map.put(new String("wangsiwei"), "a");
		map.put(new String("wangsjksjj"), "a");
		//通知回收
		System.gc();
		System.runFinalization();
		System.out.println(map.size());
	}
}



*************Identityhashmap***************
键比较的是地址，而不是比较hashCode与equals，
package weak;
import java.util.IdentityHashMap;
/**
 * Identityhashmap 键比较的是地址
 * @author 王思伟
 *
 */
public class tity {
	public static void main(String [] args) {
		IdentityHashMap<String,String> map=new IdentityHashMap<String,String>();
		//此时在常量池中只会有一个键，在常量池中相同的对像只保留一个
		map.put("a", "1");
		map.put("a", "2");
		//此对象的“a”在堆中
		map.put(new String("a"),"5");
		System.out.println(map.size());
	}
}



************enumMap键要求为枚举的值*************
package weak;
import java.util.EnumMap;
/**
 * enumMap键要求为枚举的值
 * @author 王思伟
 *
 */
public class enumap {
	public static void main(String [] args) {
	EnumMap<wang,String> map=new EnumMap<wang,String>(wang.class);
	map.put(wang.eeee, "c");
	map.put(wang.iii, "1");
	map.put(wang.sss, "2");
	map.put(wang.www, "3");
	System.out.println(map.size());
	
	}
}
//枚举
enum wang{
	www,sss,iii,eeee;
}


*************用Collections来实现同步和只读设置***************************
                                                                                                                实现同步
package tongbu;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * 使用collections管理同步容器
 * synchronizedList(list);
 * synchronizedMap(list);
 * synchronizedSet(list);
 * @author 王思伟
 *
 */
public class 德莫 {
	public static void main(String [] args) {
		List<String> list=new ArrayList<String>();
		list.add("wansiswei");
		list.add("weewweowo");
		list.add("dsdsdsdd");
		//list 同步
		List<String> arlist=Collections.synchronizedList(list);
		System.out.println("线程安全执行完毕");
		
	}
}
                                                                                                               实现只读


 三种形式：
 * emptyxxx()  不可变的空的容器
 * singletonxxx 只有一个元素的不可变容器
 * unmodifiablexxx 不可变容器

具体例子：
package tongbu;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * 只读设置
 * 三种形式：
 * emptyxxx()  不可变的空的容器
 * singletonxxx 只有一个元素的不可变容器
 * unmodifiablexxx 不可变容器
 * 
 * @author 王思伟
 *
 */
public class zhidu {
	public static void main(String [] args) {
		Map<String,String> map=new HashMap<String,String>();
		map.put("wang", "12");
		map.put("wang1", "123");
		map.put("wang2", "123");
		map.put("wang3", "123");
		Map<String,String> ap=Collections.unmodifiableMap(map);
		//设置为只读后在添加键值对会抛出异常
		ap.put("dsds", "klklk");//不能操作
		System.out.println(ap.size());
		
		//一个元素的容器的测试
		List<String> list= Collections.singletonList(new String());
		list.add("ksjkds");//报错
		
		//
	}
}



****************************************************************************IO流*************************************************************
file类：文件和目录路径名的抽象表示，不代表文件本身，就是联系，程序和文件夹之间的联系
&&&&两个常用的常量&&&&
 * 1.路径分割符  ;
 * 2.名称分割符 window是\  非window是/


package file;
import java.io.File;
/**
 * 两个常用的常量
 * 1.路径分割符  ;
 * 2.名称分割符 window是\  非window是/
 * @author 王思伟
 *
 */
public class demo1 {
	public static void main(String [] args) {
		System.out.println(File.pathSeparator);//路径分隔符
		System.out.println(File.separator);
		//第一种 路径表现形式,一个\有特殊的含义表示转义
		String path="D:\\ll\\dd";
		//第二种 动态生成时使用
		path="D:"+File.separator+"11"+File.separator+"DD";
		//第三种
		path="D:/11/dd";
	}
}

&&&&&&&如何构建file对像&&&&&
两种方式构建：
1.绝对路径
2.相对路径






